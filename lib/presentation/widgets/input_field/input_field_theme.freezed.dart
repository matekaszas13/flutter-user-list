// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'input_field_theme.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$InputFieldState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() active,
    required TResult Function() disabled,
    required TResult Function() focused,
    required TResult Function() error,
    required TResult Function() focusedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? active,
    TResult? Function()? disabled,
    TResult? Function()? focused,
    TResult? Function()? error,
    TResult? Function()? focusedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? active,
    TResult Function()? disabled,
    TResult Function()? focused,
    TResult Function()? error,
    TResult Function()? focusedError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ActiveInputState value) active,
    required TResult Function(DisabledInputState value) disabled,
    required TResult Function(FocusedInputState value) focused,
    required TResult Function(ErrorInputState value) error,
    required TResult Function(FocusedErrorInputState value) focusedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ActiveInputState value)? active,
    TResult? Function(DisabledInputState value)? disabled,
    TResult? Function(FocusedInputState value)? focused,
    TResult? Function(ErrorInputState value)? error,
    TResult? Function(FocusedErrorInputState value)? focusedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ActiveInputState value)? active,
    TResult Function(DisabledInputState value)? disabled,
    TResult Function(FocusedInputState value)? focused,
    TResult Function(ErrorInputState value)? error,
    TResult Function(FocusedErrorInputState value)? focusedError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InputFieldStateCopyWith<$Res> {
  factory $InputFieldStateCopyWith(
          InputFieldState value, $Res Function(InputFieldState) then) =
      _$InputFieldStateCopyWithImpl<$Res, InputFieldState>;
}

/// @nodoc
class _$InputFieldStateCopyWithImpl<$Res, $Val extends InputFieldState>
    implements $InputFieldStateCopyWith<$Res> {
  _$InputFieldStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ActiveInputStateCopyWith<$Res> {
  factory _$$ActiveInputStateCopyWith(
          _$ActiveInputState value, $Res Function(_$ActiveInputState) then) =
      __$$ActiveInputStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ActiveInputStateCopyWithImpl<$Res>
    extends _$InputFieldStateCopyWithImpl<$Res, _$ActiveInputState>
    implements _$$ActiveInputStateCopyWith<$Res> {
  __$$ActiveInputStateCopyWithImpl(
      _$ActiveInputState _value, $Res Function(_$ActiveInputState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ActiveInputState extends ActiveInputState {
  const _$ActiveInputState() : super._();

  @override
  String toString() {
    return 'InputFieldState.active()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ActiveInputState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() active,
    required TResult Function() disabled,
    required TResult Function() focused,
    required TResult Function() error,
    required TResult Function() focusedError,
  }) {
    return active();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? active,
    TResult? Function()? disabled,
    TResult? Function()? focused,
    TResult? Function()? error,
    TResult? Function()? focusedError,
  }) {
    return active?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? active,
    TResult Function()? disabled,
    TResult Function()? focused,
    TResult Function()? error,
    TResult Function()? focusedError,
    required TResult orElse(),
  }) {
    if (active != null) {
      return active();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ActiveInputState value) active,
    required TResult Function(DisabledInputState value) disabled,
    required TResult Function(FocusedInputState value) focused,
    required TResult Function(ErrorInputState value) error,
    required TResult Function(FocusedErrorInputState value) focusedError,
  }) {
    return active(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ActiveInputState value)? active,
    TResult? Function(DisabledInputState value)? disabled,
    TResult? Function(FocusedInputState value)? focused,
    TResult? Function(ErrorInputState value)? error,
    TResult? Function(FocusedErrorInputState value)? focusedError,
  }) {
    return active?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ActiveInputState value)? active,
    TResult Function(DisabledInputState value)? disabled,
    TResult Function(FocusedInputState value)? focused,
    TResult Function(ErrorInputState value)? error,
    TResult Function(FocusedErrorInputState value)? focusedError,
    required TResult orElse(),
  }) {
    if (active != null) {
      return active(this);
    }
    return orElse();
  }
}

abstract class ActiveInputState extends InputFieldState {
  const factory ActiveInputState() = _$ActiveInputState;
  const ActiveInputState._() : super._();
}

/// @nodoc
abstract class _$$DisabledInputStateCopyWith<$Res> {
  factory _$$DisabledInputStateCopyWith(_$DisabledInputState value,
          $Res Function(_$DisabledInputState) then) =
      __$$DisabledInputStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DisabledInputStateCopyWithImpl<$Res>
    extends _$InputFieldStateCopyWithImpl<$Res, _$DisabledInputState>
    implements _$$DisabledInputStateCopyWith<$Res> {
  __$$DisabledInputStateCopyWithImpl(
      _$DisabledInputState _value, $Res Function(_$DisabledInputState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DisabledInputState extends DisabledInputState {
  const _$DisabledInputState() : super._();

  @override
  String toString() {
    return 'InputFieldState.disabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DisabledInputState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() active,
    required TResult Function() disabled,
    required TResult Function() focused,
    required TResult Function() error,
    required TResult Function() focusedError,
  }) {
    return disabled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? active,
    TResult? Function()? disabled,
    TResult? Function()? focused,
    TResult? Function()? error,
    TResult? Function()? focusedError,
  }) {
    return disabled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? active,
    TResult Function()? disabled,
    TResult Function()? focused,
    TResult Function()? error,
    TResult Function()? focusedError,
    required TResult orElse(),
  }) {
    if (disabled != null) {
      return disabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ActiveInputState value) active,
    required TResult Function(DisabledInputState value) disabled,
    required TResult Function(FocusedInputState value) focused,
    required TResult Function(ErrorInputState value) error,
    required TResult Function(FocusedErrorInputState value) focusedError,
  }) {
    return disabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ActiveInputState value)? active,
    TResult? Function(DisabledInputState value)? disabled,
    TResult? Function(FocusedInputState value)? focused,
    TResult? Function(ErrorInputState value)? error,
    TResult? Function(FocusedErrorInputState value)? focusedError,
  }) {
    return disabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ActiveInputState value)? active,
    TResult Function(DisabledInputState value)? disabled,
    TResult Function(FocusedInputState value)? focused,
    TResult Function(ErrorInputState value)? error,
    TResult Function(FocusedErrorInputState value)? focusedError,
    required TResult orElse(),
  }) {
    if (disabled != null) {
      return disabled(this);
    }
    return orElse();
  }
}

abstract class DisabledInputState extends InputFieldState {
  const factory DisabledInputState() = _$DisabledInputState;
  const DisabledInputState._() : super._();
}

/// @nodoc
abstract class _$$FocusedInputStateCopyWith<$Res> {
  factory _$$FocusedInputStateCopyWith(
          _$FocusedInputState value, $Res Function(_$FocusedInputState) then) =
      __$$FocusedInputStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FocusedInputStateCopyWithImpl<$Res>
    extends _$InputFieldStateCopyWithImpl<$Res, _$FocusedInputState>
    implements _$$FocusedInputStateCopyWith<$Res> {
  __$$FocusedInputStateCopyWithImpl(
      _$FocusedInputState _value, $Res Function(_$FocusedInputState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FocusedInputState extends FocusedInputState {
  const _$FocusedInputState() : super._();

  @override
  String toString() {
    return 'InputFieldState.focused()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FocusedInputState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() active,
    required TResult Function() disabled,
    required TResult Function() focused,
    required TResult Function() error,
    required TResult Function() focusedError,
  }) {
    return focused();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? active,
    TResult? Function()? disabled,
    TResult? Function()? focused,
    TResult? Function()? error,
    TResult? Function()? focusedError,
  }) {
    return focused?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? active,
    TResult Function()? disabled,
    TResult Function()? focused,
    TResult Function()? error,
    TResult Function()? focusedError,
    required TResult orElse(),
  }) {
    if (focused != null) {
      return focused();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ActiveInputState value) active,
    required TResult Function(DisabledInputState value) disabled,
    required TResult Function(FocusedInputState value) focused,
    required TResult Function(ErrorInputState value) error,
    required TResult Function(FocusedErrorInputState value) focusedError,
  }) {
    return focused(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ActiveInputState value)? active,
    TResult? Function(DisabledInputState value)? disabled,
    TResult? Function(FocusedInputState value)? focused,
    TResult? Function(ErrorInputState value)? error,
    TResult? Function(FocusedErrorInputState value)? focusedError,
  }) {
    return focused?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ActiveInputState value)? active,
    TResult Function(DisabledInputState value)? disabled,
    TResult Function(FocusedInputState value)? focused,
    TResult Function(ErrorInputState value)? error,
    TResult Function(FocusedErrorInputState value)? focusedError,
    required TResult orElse(),
  }) {
    if (focused != null) {
      return focused(this);
    }
    return orElse();
  }
}

abstract class FocusedInputState extends InputFieldState {
  const factory FocusedInputState() = _$FocusedInputState;
  const FocusedInputState._() : super._();
}

/// @nodoc
abstract class _$$ErrorInputStateCopyWith<$Res> {
  factory _$$ErrorInputStateCopyWith(
          _$ErrorInputState value, $Res Function(_$ErrorInputState) then) =
      __$$ErrorInputStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ErrorInputStateCopyWithImpl<$Res>
    extends _$InputFieldStateCopyWithImpl<$Res, _$ErrorInputState>
    implements _$$ErrorInputStateCopyWith<$Res> {
  __$$ErrorInputStateCopyWithImpl(
      _$ErrorInputState _value, $Res Function(_$ErrorInputState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ErrorInputState extends ErrorInputState {
  const _$ErrorInputState() : super._();

  @override
  String toString() {
    return 'InputFieldState.error()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ErrorInputState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() active,
    required TResult Function() disabled,
    required TResult Function() focused,
    required TResult Function() error,
    required TResult Function() focusedError,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? active,
    TResult? Function()? disabled,
    TResult? Function()? focused,
    TResult? Function()? error,
    TResult? Function()? focusedError,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? active,
    TResult Function()? disabled,
    TResult Function()? focused,
    TResult Function()? error,
    TResult Function()? focusedError,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ActiveInputState value) active,
    required TResult Function(DisabledInputState value) disabled,
    required TResult Function(FocusedInputState value) focused,
    required TResult Function(ErrorInputState value) error,
    required TResult Function(FocusedErrorInputState value) focusedError,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ActiveInputState value)? active,
    TResult? Function(DisabledInputState value)? disabled,
    TResult? Function(FocusedInputState value)? focused,
    TResult? Function(ErrorInputState value)? error,
    TResult? Function(FocusedErrorInputState value)? focusedError,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ActiveInputState value)? active,
    TResult Function(DisabledInputState value)? disabled,
    TResult Function(FocusedInputState value)? focused,
    TResult Function(ErrorInputState value)? error,
    TResult Function(FocusedErrorInputState value)? focusedError,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorInputState extends InputFieldState {
  const factory ErrorInputState() = _$ErrorInputState;
  const ErrorInputState._() : super._();
}

/// @nodoc
abstract class _$$FocusedErrorInputStateCopyWith<$Res> {
  factory _$$FocusedErrorInputStateCopyWith(_$FocusedErrorInputState value,
          $Res Function(_$FocusedErrorInputState) then) =
      __$$FocusedErrorInputStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FocusedErrorInputStateCopyWithImpl<$Res>
    extends _$InputFieldStateCopyWithImpl<$Res, _$FocusedErrorInputState>
    implements _$$FocusedErrorInputStateCopyWith<$Res> {
  __$$FocusedErrorInputStateCopyWithImpl(_$FocusedErrorInputState _value,
      $Res Function(_$FocusedErrorInputState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FocusedErrorInputState extends FocusedErrorInputState {
  const _$FocusedErrorInputState() : super._();

  @override
  String toString() {
    return 'InputFieldState.focusedError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FocusedErrorInputState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() active,
    required TResult Function() disabled,
    required TResult Function() focused,
    required TResult Function() error,
    required TResult Function() focusedError,
  }) {
    return focusedError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? active,
    TResult? Function()? disabled,
    TResult? Function()? focused,
    TResult? Function()? error,
    TResult? Function()? focusedError,
  }) {
    return focusedError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? active,
    TResult Function()? disabled,
    TResult Function()? focused,
    TResult Function()? error,
    TResult Function()? focusedError,
    required TResult orElse(),
  }) {
    if (focusedError != null) {
      return focusedError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ActiveInputState value) active,
    required TResult Function(DisabledInputState value) disabled,
    required TResult Function(FocusedInputState value) focused,
    required TResult Function(ErrorInputState value) error,
    required TResult Function(FocusedErrorInputState value) focusedError,
  }) {
    return focusedError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ActiveInputState value)? active,
    TResult? Function(DisabledInputState value)? disabled,
    TResult? Function(FocusedInputState value)? focused,
    TResult? Function(ErrorInputState value)? error,
    TResult? Function(FocusedErrorInputState value)? focusedError,
  }) {
    return focusedError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ActiveInputState value)? active,
    TResult Function(DisabledInputState value)? disabled,
    TResult Function(FocusedInputState value)? focused,
    TResult Function(ErrorInputState value)? error,
    TResult Function(FocusedErrorInputState value)? focusedError,
    required TResult orElse(),
  }) {
    if (focusedError != null) {
      return focusedError(this);
    }
    return orElse();
  }
}

abstract class FocusedErrorInputState extends InputFieldState {
  const factory FocusedErrorInputState() = _$FocusedErrorInputState;
  const FocusedErrorInputState._() : super._();
}
